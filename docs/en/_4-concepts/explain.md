Basically, the main difference is that instead of bundling one input into one bundle, we now bundle an array of inputs into one bundle. This is done using [esbuild](https://esbuild.github.io/) with a custom plugin. The backend implementation is platform-agnostic, and does not rely on the file system. Instead,
an input is a object containing a name and source (like a virtual file).

When the build process starts, the bundler first looks for an index input. This is the entry point for the instrument and must include a default export.

To resolve the index file, the bundler checks for the following file names (in order):

- `index.tsx`
- `index.jsx`
- `index.ts`
- `index.js`

Once found, this index file is injected into a string which is passed as the input to esbuild. For example, if the index file is `index.js`, then it is passed the following string:

`import instrument from './index.js'; var __exports = instrument;`

Our custom plugin assumes responsibility for resolving all imports found. In this case, we resolve the static relative import `'./index.js` which exists in the inputs. We then return the content of the index input to esbuild for further processing. In this case, esbuild will look for imports in the content of the index, and pass any results to our resolver. The resolver marks any dynamic imports starting with `/` as external (e.g., import('/runtime/foo.js)'). It looks for any static imports inside the inputs and throws an exception if it is not found. If it is found, the content is passed to esbuild and the bundling process continues.

Ultimately, this results in one JavaScript virtual file being generated, and one CSS virtual file being generated (if CSS is imported). If applicable, the CSS file is a bundle of all stylesheets used by the instrument.

Since we know that the JavaScript file contains a variable `__exports` which is the default export of the instrument, the CSS is converted to base64 and inserted into the JavaScript bundle as follows:

```js
// lots of stuff generated by esbuild
var __exports = index_default;
__exports.content.__injectHead.style = '...'; // base64 encoded string
```

This new content is then passed into the esbuild transpiler as a single asynchronous [Immediately Invoked Function Expression](https://developer.mozilla.org/en-US/docs/Glossary/IIFE). At this point, the code can be minified and tree shaken (i.e., dead code removed).

For example:

```js
`(async () => {
  // code with styles injected (if applicable)
  return __exports;
} )()`;
```

Then, when rendering interactive instruments, a script looks for the special `content.__injectHead` property and decodes the styles if found. This is inserted into the document head before the `render` method is called.
